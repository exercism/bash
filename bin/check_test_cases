#!/usr/bin/env bash

die() { echo "$*" >&2; exit 1; }

if [[ "$(IFS="."; echo "${BASH_VERSINFO[*]:0:2}")" < "4.3" ]]; then
    die "This script requires bash v4.3 or greater"
fi

usage() {
    cat <<END_USAGE >&2
Validate the test cases specified in the canonical data
versus the test implemented as listed in .meta/tests.toml

usage: $0 [-avh] [exercise ...]

where:
    -a  validate all exercises, default only those specified
    -v  show the resusts for each test case, default is to
        show only the unimplemted ones

Exit status is non-zero if there are any unimplemented test cases.
END_USAGE
}

dependencies() {
    command -v gron >/dev/null ||
      die "Install gron: go get -u github.com/tomnomnom/gron"

    command -v yj >/dev/null ||
      die "Install yj: go get -u github.com/sclevine/yj"

    [[ -d ../problem-specifications ]] ||
      die "Clone the exercism/problem-specifications repo."
}

parseOptions() {
    declare -ga exercises
    declare -g verbose=false
    local all=false
    local OPTIND OPTARG

    while getopts ":avh" opt; do
        case $opt in
            h) usage; exit ;;
            v) verbose=true ;;
            a) all=true ;;
            *) die "invalid option $OPTARG" ;;
        esac
    done
    shift $((OPTIND - 1))

    if $all; then
        mapfile -t exercises < <(
            find ./exercises -mindepth 1 -maxdepth 1 -type d -printf "%f\n"
        )
    else
        exercises=( "$@" )
    fi
}

# Parse a canonical-data.json file for an exercise.
# Sets 2 shell variables, whose varnames are passed in as params:
#   uuids: array of test case UUIDs, in the order they apprear
#   map: associative array of UUID => description
#
testSpecs() {
    local exercise=$1
    local -n map=$2
    local -n uuids=$3
    local json=../problem-specifications/exercises/"$exercise"/canonical-data.json
    if ! [[ -f "$json" ]]; then
        if $verbose; then
            printf "No canonical data for %s\n\n" "$exercise" >&2
        fi
        return
    fi
    source <(
        gron "$json" | awk -F' = ' '
            function join(start, end, separator,   result,i) {
                if (separator == "") separator = FS
                result = $start
                for (i = start+1; i <= end; i++)
                    result = result separator $i
                return result
            }
            function trim(s) {
                return gensub("\"(.+)\";", "\\1", 1, s)
            }
            $1 ~ /\.uuid$/        {
                id = trim(join(2, NF))
                uuids = uuids id " "
                uuid[substr($1, 1, length($1)-5)] = id
            }
            $1 ~ /\.description$/ {
                desc[substr($1, 1, length($1)-12)] = trim(join(2, NF))
            }
            END {
                print "uuids=(", uuids, ")"
                print "map=("
                for (k in uuid) {
                    printf "[\"%s\"]=\"%s\"\n", uuid[k], desc[k]
                }
                print ")"
            }
        '
    )
}

# Parse a ./meta/tests.toml file for an exercise.
# Sets a shell variables, whose varname is passed in as a param:
#   map: associative array of UUID => isImplemented status
#
testsImpl() {
    local exercise=$1
    local -n map=$2
    local toml="./exercises/$exercise/.meta/tests.toml"
    if ! [[ -f "$toml" ]]; then
        echo "MISSING: $toml" >&2
        return
    fi
    source <(
        yj -tj < "$toml" | gron | awk -F '[][ ]' '
            NF == 7 {printf "map[%s]=%s\n", $4, $7}
        '
    )
}

validate() {
    local exercise=$1
    local -a testUuidsOrdered descriptionsOrdered
    local -A testsSpecified testsImplemented results

    testSpecs "$exercise" testsSpecified testUuidsOrdered
    (( ${#testsSpecified[@]} == 0 )) && return

    testsImpl "$exercise" testsImplemented

    local desc status=0
    for uuid in "${testUuidsOrdered[@]}"; do
        desc=${testsSpecified[$uuid]}
        if ! [[ -v testsImplemented[$uuid] ]]; then
            results[$desc]="not implemented"
            descriptionsOrdered+=("$desc")
            status=1
        elif ! ${testsImplemented[$uuid]}; then
            results[$desc]="excluded"
            descriptionsOrdered+=("$desc")
        elif $verbose; then
            results[$desc]="implemented"
            descriptionsOrdered+=("$desc")
        fi
    done

    report
    return $status
}

report() {
    local width
    if (( ${#results[@]} > 0 )); then
        echo "Exercise $exercise"
        width=$(
            for desc in "${descriptionsOrdered[@]}"; do
                echo "${#desc}"
            done | sort -n | tail -n 1
        )
        for desc in "${descriptionsOrdered[@]}"; do
            printf "  %-*s = %s\n" $width "$desc" "${results[$desc]}"
        done
        echo
    fi
}

main() {
    cd "$(dirname -- "$0")/.." >/dev/null || die
    dependencies 
    parseOptions "$@"   # sets global vars "exercises" and "verbose"

    if (( ${#exercises[@]} == 0 )); then
        echo "Nothing to do"
        exit
    fi

    local exitStatus=0
    while IFS= read -r exercise; do
        validate "$exercise"
        (( exitStatus |= $? ))
    done < <( printf '%s\n' "${exercises[@]}" | sort )
    return $exitStatus
}

main "$@"
